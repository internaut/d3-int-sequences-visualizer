<!DOCTYPE html>
<meta charset="utf-8">
<head>
<title>Circular decimal places with d3.js</title>
<style>
	body {
		font: 10px sans-serif;
        background: black;
        color: white;
	}

    svg {
        background: black;
        border: 1px solid white;
    }

    .section text {
        font-size: 22px;
        font-weight: bold;
        fill: white;
    }

    .connection {
        /*stroke: white;*/
        stroke-width: 2;
        fill: none;
    }

    #bgSymbol {
        fill: white;
        stroke: white;
        stroke-opacity: 0.5;
        stroke-width: 2;
        fill-opacity: 0.33;
        font-style: italic;
    }
</style>

<script src="d3.js" charset="utf-8"></script>

</head>
<body>

<div id="canvas">

</div>

<div id="options">
    <label for="constant_from_file">Choose a constant</label>
    <select id="constant_from_file" name="constant_from_file">

    </select>
    <label for="line_interpolation">Line Interpolation</label>
    <select id="line_interpolation" name="line_interpolation">

    </select>
</div>

<script>
    /**
     * TODOs:
     * - allow fetch number from OEIS, e.g. http://oeis.org/A002262/b002262.txt
     *   -> dyn. number of segments
     * - allow to enter own constant
     * - number of digits to draw
     * - adjust transparency
     * - export to PDF
     */

    /*
     Define some constants
     */
     
    var width = 700,
        height = 700,
        innerRadius = Math.min(width, height) * .4,
        outerRadius = innerRadius * 1.1,
        middlePointRadius = innerRadius * 0.5;

    var animMaxMs = 500;
    var numDigitsToDraw = 100;
    
    var digits = null;      // array of ints. only the digits to draw
    var allDigits = null;   // array of ints. all loaded digits
    
    var minDigit = null;    // min of <digits>
    var maxDigit = null;    // max of <digits>
    var numSecs = null;     // max - min + 1
    
    var fillPerDigit = null;
    var secCircum = null;   // section circumference
    var arcData = null;
    
    /*
     Defne options
     */
    
    var constantsOptions = [
        ['π', 'pi.txt'],
        ['e', 'e.txt'],
        ['√2', 'sqrt2.txt'],
        ['ɸ (golden ratio)', 'phi.txt'],
        ['OEIS A002262', 'b002262.txt'],
        ['OEIS A025581', 'b025581.txt'],
    ];
    
    var interpolateOptions = [
        'basis',
        'linear',
        'step',
        'bundle',
        'cardinal',
        'monotone',
    ];
    
    
    /*
     Set up options
     */
     
    var selectedConstantsOption = constantsOptions[4];
        
    d3.select('#constant_from_file')
        .on('change', function(opt) { loadDigitsAndDraw(this.value); } )
        .selectAll('option')
        .data(constantsOptions)
        .enter().append('option')
        .attr('value', function (d) { return d[1]; })
        .text(function (d) { return d[0]; });


    var selectedInterpolateOption = interpolateOptions[0];
    
    d3.select('#line_interpolation')
        .on('change', function(opt) { selectedInterpolateOption = this.value; drawDigits(); })
        .selectAll('option')
        .data(interpolateOptions)
        .enter().append('option')
        .attr('value', function (d) { return d; })
        .text(function (d) { return d; });
    
    
    /*
     Functions for loading and parsing
     */
    function parseTxtFile(content) {
        var dotIdx = content.indexOf('.') + 1;
        var fromDot = content.substr(dotIdx);       // only use the decimal places
        
        var digitsStr = fromDot.replace(/[\D]/g, '');  // delete everything but digits
        
        var digitsArr = [];
        for (i = 0; i < digitsStr.length; i++) {
            digitsArr.push(parseInt(digitsStr.charAt(i)));
        }
        
        return digitsArr;
    }
    
    function parseOEISFile(content) {
        var lines = content.match(/^.*([\n\r]+|$)/gm);
        var digitsArr = [];
        for (var i = 0; i < lines.length; i++) {
            var l = lines[i];
            var parts = l.split(' ');
            if (parts.length == 2) {
                digitsArr.push(parseInt(parts[1]));
            }
        }
        
        return digitsArr;
    }
    
    function loadDigitsAndDraw(f) {
        console.log("will constant from load file '" + f + "'");
        d3.text(f, function (content) {
            if (f[0] == 'b') {
                allDigits = parseOEISFile(content);
            } else {
                allDigits = parseTxtFile(content);            
            }

            digits = allDigits.slice(0, numDigitsToDraw);
            minDigit = Math.min.apply(Math, digits);
            maxDigit = Math.max.apply(Math, digits);
            
            numSecs = maxDigit - minDigit + 1;
            secCircum = Math.PI * (2.0 / numSecs);
            
            // create circular sections
            setupSections();
            
            console.log("starting draw animation");
            drawDigits();
        });
    }    

    /*
     Create an SVG element
     */
    var svg = d3.select("#canvas").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");  // set to the center

    /*
     Create the background symbol at first
     */
    /*var bgSymbol = svg.append("text")
            .attr("id", "bgSymbol")
            .style("font-size", Math.min(width, height) * 0.5)
            .text("π");
    var bgSymbolSize = [bgSymbol.node().clientWidth, bgSymbol.node().clientHeight];
    bgSymbol.attr("dx", -bgSymbolSize[0] / 2.0);
    bgSymbol.attr("dy", bgSymbolSize[1] / 4.0);*/


    function createArcData() {
        /*
         An arc data object consists of the index, value (the digit itself) and the start and end angle of the arc section.
         */
        arcData = [];
        for (var dgt = minDigit; dgt <= maxDigit; dgt++) {
            var arcDataObj = {
                index: dgt,
                value: String(dgt),
                startAngle: secCircum * dgt,
                endAngle: secCircum * (dgt + 1)
            };

            arcData.push(arcDataObj);
        }
    }
    
    function setupSections() {
        createArcData();
        
        /*
         Make a d3.js arc object to use it for drawing the sections.
         */
        var arc = d3.svg.arc()
                .innerRadius(innerRadius)
                .outerRadius(outerRadius);

        /*
         Create all section groups using the arc data
         */
        var section = svg.append("g").selectAll(".section")
                .data(arcData)
                .enter().append("g")
                .attr("class", "section");

        /*
         Create the fill color for each section
         */
        fillPerDigit = d3.scale.category20().domain(d3.range(minDigit, maxDigit));

        /*
         Create all section paths inside the section groups using the d3.js arc object
         */
        var sectionPath = section.append("path")
                .attr("id", function(d, i) { return "section" + i; })
                .attr("d", arc)                    // this sets the geometry information
                .style("fill", function(d, i) { return fillPerDigit(i); })     // fill and stroke ...
                .style("stroke", function(d, i) { return fillPerDigit(i); });  // ... get the same color

        /*
         Set the digit texts inside the section groups
         */
        var sectionText = section.append("text")
                .attr("x", 4)
                .attr("dy", 22);
        sectionText.append("textPath")
                .attr("xlink:href", function(d, i) { return "#section" + i; })
                .text(function(d) { return d.value; });
    }

    /**
     * Starts the drawing animation for the digits.
     */
    function drawDigits() {
        // create or select a group for the connection lines
        var connectionGroup = svg.select("g.connection");
        if (connectionGroup.empty()) {
            connectionGroup = svg.append("g").attr("class", "connection");
        } else {    
            connectionGroup.interrupt() // cancel the current transition
                           .transition(); // preempt any scheduled transitions
            connectionGroup.selectAll("path").remove();
        }
    
        // calculate a histogram for the digits string
        // we need this in order to know how many connection lines will be drawn per digit section
        // so that we have the right spacing between the line starting/ending points
        var hist = histForDigits(digits);
        
        var grads = svg.selectAll("linearGradient");

        // base line function
        var line = d3.svg.line()
                .x(function (d) { return d[0] })
                .y(function (d) { return d[1] })
                .interpolate(selectedInterpolateOption);

        // a loop that goes through the digits
        var prevPoint = null;
        var prevDgt = null;
        var prevAnimMs = 0;
        var drawn = new Array(numSecs).fill(0);  // saves how many connection lines per digit have already be drawn
        var numAddedLines = 0;
        for (var i = 0; i < digits.length; i++) {
            var dgtInt = digits[i];
            var dgt = String(dgtInt);
            var dgtArrIdx = dgtInt - minDigit;   // index into 0-index-based arrays like hist
            
            // get amount of how often this digit appears in the digits string
            var numOfThisDigit = hist[dgtArrIdx];  // *must* be > 0

            // get the arc data that belongs to this digit
            var arcObj = arcData[dgtInt];
            
            // calculate the angle at which the connection line starts
            
            // this is the starting angle of the section
            var angStart = arcObj.startAngle - Math.PI / 2;
            // the angle that is added per connection line of this digit
            var angSec = secCircum / (numOfThisDigit + 1);
            
            // the actual starting angle of this line
            var ang = angStart + (drawn[dgtArrIdx] + 1) * angSec;

            // the starting point of this line
            var thisPoint = [
                innerRadius * Math.cos(ang),
                innerRadius * Math.sin(ang)
            ];

            // the "tipping" point around the center
            var middlePoint = [
                middlePointRadius * Math.cos(ang),
                middlePointRadius * Math.sin(ang)
            ];

            if (prevPoint != null) {  // if this wasn't the very first line...
                // add gradient for the connection line between the two end points
                var gradId = "line-grad-" + prevDgt + "-" + dgt;

                if (svg.select(gradId).node() == null) {
                    svg.append("linearGradient")
                            .attr("id", gradId)
                            .attr("gradientUnits", "userSpaceOnUse")
                            .attr("x1", prevPoint[0]).attr("y1", prevPoint[1])
                            .attr("x2", thisPoint[0]).attr("y2", thisPoint[1])
                            .selectAll("stop")
                            .data(function (d) { return [prevDgt, dgt]})
                            .enter().append("stop")
                            .attr("offset", function(_, i) { return i * 100 + "%"; })
                            .attr("stop-color", function(d) {
                                return d3.rgb(fillPerDigit(d));
                            });
                }

                // add connection line
                // the animation duration slowly gets shorter, to make the animation run faster with time
                var animMs = animMaxMs * (1 - (1 + Math.log((numAddedLines + 1) / (digits.length - 1)) / (Math.E * Math.E)));
                
                // finally add the line path element
                var connectionLine = connectionGroup.append("path")
                        .attr("d", line([prevPoint, middlePoint, thisPoint]))       // set the line geometry
                        .style("stroke", function(d) { return "url(#" + gradId })   // set the gradient to use
                        .style("stroke-opacity", 0.0)
                        .transition()       // make the animation
                        .duration(animMs)
                        .delay(prevAnimMs)  // only start after the previous line animation is finished
                        .style("stroke-opacity", 0.75);

                prevAnimMs = prevAnimMs + animMs;
                numAddedLines++;
            }

            drawn[dgtArrIdx]++;
            prevPoint = thisPoint;
            prevDgt = dgt;
        }
    }

    /**
     * Calculates a histogram for an array of <digits>.
     */
    function histForDigits(digits) {
        // init
        var hist = new Array(numSecs).fill(0);

        // count
        for (var i = 0; i < digits.length; i++) {
            hist[digits[i] - minDigit]++;
        }

        return hist;
    }
    
    /**
     * Load the default constants file and start the draw animation
     */
    loadDigitsAndDraw(selectedConstantsOption[1]);
</script>

</body>
