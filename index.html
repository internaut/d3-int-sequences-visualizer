<!DOCTYPE html>
<meta charset="utf-8">
<head>
<title>Circular decimal places with d3.js</title>
<style>
	body {
		font: 10px sans-serif;
        background: black;
        color: white;
	}

    svg {
        background: black;
        border: 1px solid white;
    }

    .section text {
        font-size: 22px;
        font-weight: bold;
        fill: white;
    }

    .connection {
        /*stroke: white;*/
        stroke-width: 2;
        fill: none;
    }

    #bgSymbol {
        fill: white;
        stroke: white;
        stroke-opacity: 0.5;
        stroke-width: 2;
        fill-opacity: 0.33;
        font-style: italic;
    }
</style>

<script src="d3.js" charset="utf-8"></script>

</head>
<body>

<div id="canvas">

</div>

<div id="options">
    <label for="constant_from_file">Choose a constant</label>
    <select id="constant_from_file" name="constant_from_file">

    </select>
    <label for="line_interpolation">Line Interpolation</label>
    <select id="line_interpolation" name="line_interpolation">

    </select>
</div>

<script>
    /**
     * TODOs:
     * - allow to enter own constant
     * - number of digits to draw
     * - adjust transparency
     * - export to PDF
     */

    /*
     Define some constants
     */
     
    var width = 700,
        height = 700,
        innerRadius = Math.min(width, height) * .4,
        outerRadius = innerRadius * 1.1,
        middlePointRadius = innerRadius * 0.5;

    var animMaxMs = 500;
    var numDigitsToDraw = 100;
    
    var digits = null;
    
    var secCircum = Math.PI * .2;   // circumference of a section for a digit (full circle divided by 10)
    
    /*
     Defne options
     */
    
    var constantsOptions = [
        ['π', 'pi.txt'],
        ['e', 'e.txt'],
        ['√2', 'sqrt2.txt'],
        ['ɸ (golden ratio)', 'phi.txt'],
    ];
    
    var interpolateOptions = [
        'basis',
        'linear',
        'step',
        'bundle',
        'cardinal',
        'monotone',
    ];
    
    
    /*
     Set up options
     */
     
    var selectedConstantsOption = constantsOptions[0];
    
    function loadConstantFromFileAndDraw(f) {
        console.log("will constant from load file '" + f + "'");
        d3.text(f, function (content) {
            var dotIdx = content.indexOf('.') + 1;
            var fromDot = content.substr(dotIdx);       // only use the decimal places
        
            var allDigits = fromDot.replace(/[\D]/g, '');  // delete everything but digits
            digits = allDigits.substr(0, numDigitsToDraw);
            
            console.log("starting draw animation");
            drawDigits();
        });
    }
    
    d3.select('#constant_from_file')
        .on('change', function(opt) { loadConstantFromFileAndDraw(this.value); } )
        .selectAll('option')
        .data(constantsOptions)
        .enter().append('option')
        .attr('value', function (d) { return d[1]; })
        .text(function (d) { return d[0]; });


    var selectedInterpolateOption = interpolateOptions[0];
    
    d3.select('#line_interpolation')
        .on('change', function(opt) { selectedInterpolateOption = this.value; drawDigits(); })
        .selectAll('option')
        .data(interpolateOptions)
        .enter().append('option')
        .attr('value', function (d) { return d; })
        .text(function (d) { return d; });
    
    /*
     Define the digits for the arc as array
     */

    var from0to9 = [];
    for (var i = 0; i < 10; i++) {
        from0to9.push(String(i));
    }

    /*
     An arc data object consists of the index, value (the digit itself) and the start and end angle of the arc section.
     */
    var from0to9ArcData = [];
    from0to9.forEach(function (digit, i) {
        var arcDataObj = {
            index: i,
            value: digit,
            startAngle: secCircum * i,
            endAngle: secCircum * (i + 1)
        };

        from0to9ArcData.push(arcDataObj);
    });


    /*
     Create an SVG element
     */
    var svg = d3.select("#canvas").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");  // set to the center

    /*
     Create the fill color for each section
     */
    var fillPerDigit = d3.scale.category10().domain(d3.range(0, 10));

    /*
     Create the background symbol at first
     */
    var bgSymbol = svg.append("text")
            .attr("id", "bgSymbol")
            .style("font-size", Math.min(width, height) * 0.5)
            .text("π");
    var bgSymbolSize = [bgSymbol.node().clientWidth, bgSymbol.node().clientHeight];
    bgSymbol.attr("dx", -bgSymbolSize[0] / 2.0);
    bgSymbol.attr("dy", bgSymbolSize[1] / 4.0);

    /*
     Make a d3.js arc object to use it for drawing the sections.
     */
    var arc = d3.svg.arc()
            .innerRadius(innerRadius)
            .outerRadius(outerRadius);

    /*
     Create all section groups using the arc data
     */
    var section = svg.append("g").selectAll(".section")
            .data(from0to9ArcData)
            .enter().append("g")
            .attr("class", "section");

    /*
     Create all section paths inside the section groups using the d3.js arc object
     */
    var sectionPath = section.append("path")
            .attr("id", function(d, i) { return "section" + i; })
            .attr("d", arc)                    // this sets the geometry information
            .style("fill", function(d, i) { return fillPerDigit(i); })     // fill and stroke ...
            .style("stroke", function(d, i) { return fillPerDigit(i); });  // ... get the same color

    /*
     Set the digit texts inside the section groups
     */
    var sectionText = section.append("text")
            .attr("x", 90)
            .attr("dy", 22);
    sectionText.append("textPath")
            .attr("xlink:href", function(d, i) { return "#section" + i; })
            .text(function(d) { return d.value; });

    /**
     * Starts the drawing animation for the digits.
     */
    function drawDigits() {
        // create or select a group for the connection lines
        var connectionGroup = svg.select("g.connection");
        if (connectionGroup.empty()) {
            connectionGroup = svg.append("g").attr("class", "connection");
        } else {    
            connectionGroup.interrupt() // cancel the current transition
                           .transition(); // preempt any scheduled transitions
            connectionGroup.selectAll("path").remove();
        }
    
        // calculate a histogram for the digits string
        // we need this in order to know how many connection lines will be drawn per digit section
        // so that we have the right spacing between the line starting/ending points
        var hist = histForDigits(digits);
        
        var grads = svg.selectAll("linearGradient");

        // base line function
        var line = d3.svg.line()
                .x(function (d) { return d[0] })
                .y(function (d) { return d[1] })
                .interpolate(selectedInterpolateOption);

        // a loop that goes through the digits
        var prevPoint = null;
        var prevDgt = null;
        var prevAnimMs = 0;
        var drawn = new Array(10).fill(0);  // saves how many connection lines per digit have already be drawn
        var numAddedLines = 0;
        for (var i = 0; i < digits.length; i++) {
            var dgt = digits.charAt(i);
            var dgtInt = parseInt(dgt);
            
            // get amount of how often this digit appears in the digits string
            var numOfThisDigit = hist[dgtInt];  // *must* be > 0

            // get the arc data that belongs to this digit
            var arcObj = from0to9ArcData[dgtInt];
            
            // calculate the angle at which the connection line starts
            
            // this is the starting angle of the section
            var angStart = arcObj.startAngle - secCircum * 2.0 - secCircum / 2.0;  // don't know why we have to substract two sections
            // the angle that is added per connection line of this digit
            var angSec = secCircum / (numOfThisDigit + 1);
            
            // the actual starting angle of this line
            var ang = angStart + (drawn[dgtInt] + 1) * angSec;

            // the starting point of this line
            var thisPoint = [
                innerRadius * Math.cos(ang),
                innerRadius * Math.sin(ang)
            ];

            // the "tipping" point around the center
            var middlePoint = [
                middlePointRadius * Math.cos(ang),
                middlePointRadius * Math.sin(ang)
            ];

            if (prevPoint != null) {  // if this wasn't the very first line...
                // add gradient for the connection line between the two end points
                var gradId = "line-grad-" + prevDgt + "-" + dgt;

                if (svg.select(gradId).node() == null) {
                    svg.append("linearGradient")
                            .attr("id", gradId)
                            .attr("gradientUnits", "userSpaceOnUse")
                            .attr("x1", prevPoint[0]).attr("y1", prevPoint[1])
                            .attr("x2", thisPoint[0]).attr("y2", thisPoint[1])
                            .selectAll("stop")
                            .data(function (d) { return [prevDgt, dgt]})
                            .enter().append("stop")
                            .attr("offset", function(_, i) { return i * 100 + "%"; })
                            .attr("stop-color", function(d) {
                                return d3.rgb(fillPerDigit(d));
                            });
                }

                // add connection line
                // the animation duration slowly gets shorter, to make the animation run faster with time
                var animMs = animMaxMs * (1 - (1 + Math.log((numAddedLines + 1) / (digits.length - 1)) / (Math.E * Math.E)));
                
                // finally add the line path element
                var connectionLine = connectionGroup.append("path")
                        .attr("d", line([prevPoint, middlePoint, thisPoint]))       // set the line geometry
                        .style("stroke", function(d) { return "url(#" + gradId })   // set the gradient to use
                        .style("stroke-opacity", 0.0)
                        .transition()       // make the animation
                        .duration(animMs)
                        .delay(prevAnimMs)  // only start after the previous line animation is finished
                        .style("stroke-opacity", 0.75);

                prevAnimMs = prevAnimMs + animMs;
                numAddedLines++;
            }

            drawn[dgtInt]++;
            prevPoint = thisPoint;
            prevDgt = dgt;
        }
    }

    /**
     * Calculates a histogram (with bins 0-9) for a string of <digits>.
     */
    function histForDigits(digits) {
        // init
        var hist = new Array(10).fill(0);

        // count
        for (var i = 0; i < digits.length; i++) {
            var dgt = digits.charAt(i);
            hist[parseInt(dgt)]++;
        }

        return hist;
    }
    
    /**
     * Load the default constants file and start the draw animation
     */
    loadConstantFromFileAndDraw(selectedConstantsOption[1]);
</script>

</body>
