<!DOCTYPE html>
<meta charset="utf-8">
<style>
	body {
		font: 10px sans-serif;
        background: black;
        color: white;
	}

    svg {
        background: black;
        border: 1px solid white;
    }

    .section text {
        font-size: 22px;
        font-weight: bold;
        fill: white;
    }

    .connection {
        /*stroke: white;*/
        stroke-width: 2;
        fill: none;
    }

    #bgSymbol {
        fill: white;
        fill-opacity: 0.75;
        font-style: italic;
    }
</style>
<body>
<script src="d3.js" charset="utf-8"></script>

<script>
    /**
     * TODOs:
     * - make interpolate fn selectable
     * - make constant selectable: pi, euler, etc.
     * - allow to enter own constant
     * - number of digits to draw
     * - adjust transparency
     * - export to PDF
     */

    var width = 700,
        height = 700,
        innerRadius = Math.min(width, height) * .4,
        outerRadius = innerRadius * 1.1,
        middlePointRadius = innerRadius * 0.5;

    var animMaxMs = 500;
    var numDigitsToDraw = 100;

    var secCircum = Math.PI * .2;   // circumference of a section for a digit (full circle divided by 10)

    var from0to9 = [];
    for (var i = 0; i < 10; i++) {
        from0to9.push(String(i));
    }

    var from0to9ArcData = [];
    from0to9.forEach(function (digit, i) {
        var arcDataObj = {
            index: i,
            value: digit,
            startAngle: secCircum * i,
            endAngle: secCircum * (i + 1)
        };

        from0to9ArcData.push(arcDataObj);
    });


    var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    var fillPerDigit = d3.scale.category10().domain(d3.range(0, 10));

    var bgSymbol = svg.append("text")
            .attr("id", "bgSymbol")
            .style("font-size", Math.min(width, height) * 0.5)
            .text("Ï€");
    var bgSymbolSize = [bgSymbol.node().clientWidth, bgSymbol.node().clientHeight];
    bgSymbol.attr("dx", -bgSymbolSize[0] / 2.0);
    bgSymbol.attr("dy", bgSymbolSize[1] / 4.0);

    var arc = d3.svg.arc()
            .innerRadius(innerRadius)
            .outerRadius(outerRadius);

    var section = svg.append("g").selectAll(".section")
            .data(from0to9ArcData)
            .enter().append("g")
            .attr("class", "section");

    var sectionPath = section.append("path")
            .attr("id", function(d, i) { return "section" + i; })
            .attr("d", arc)
            .attr("centroid", arc.centroid)
            .style("fill", function(d, i) { return fillPerDigit(i); })
            .style("stroke", function(d, i) { return fillPerDigit(i); });

    var sectionText = section.append("text")
            .attr("x", 90)
            .attr("dy", 22);
    sectionText.append("textPath")
            .attr("xlink:href", function(d, i) { return "#section" + i; })
            .text(function(d) { return d.value; });



    d3.text('pi.txt', function (content) {
        var dotIdx = content.indexOf('.') + 1;
        var fromDot = content.substr(dotIdx);
        var digits = fromDot.replace(/[\D]/g, '');

        drawDigits(digits.substr(0, numDigitsToDraw));
    });

    function drawDigits(digits) {
        var hist = histForDigits(digits);

        var connectionGroup = svg.append("g").attr("class", "connection");
        var grads = svg.selectAll("linearGradient");

        var line = d3.svg.line()
                .x(function (d) { return d[0] })
                .y(function (d) { return d[1] })
                .interpolate("basis");

        var prevPoint = null;
        var prevDgt = null;
        var prevAnimMs = 0;
        var drawn = new Array(10).fill(0);
        var numAddedLines = 0;
        for (var i = 0; i < digits.length; i++) {
            var dgt = digits.charAt(i);
            var dgtInt = parseInt(dgt);

            var numOfThisDigit = hist[dgtInt];  // *must* be > 0

            var arcObj = from0to9ArcData[dgtInt];
            //console.log(arcObj);
            var angStart = arcObj.startAngle - secCircum * 2.0 - secCircum / 2.0;  // don't know why we have to substract two sections
            var angSec = secCircum / (numOfThisDigit + 1);
            var ang = angStart + (drawn[dgtInt] + 1) * angSec;

            var thisPoint = [
                innerRadius * Math.cos(ang),
                innerRadius * Math.sin(ang)
            ];

            var middlePoint = [
                middlePointRadius * Math.cos(ang),
                middlePointRadius * Math.sin(ang)
            ];

            if (prevPoint != null) {
                // add gradient
                var gradId = "line-grad-" + prevDgt + "-" + dgt;

                if (svg.select(gradId).node() == null) {
                    svg.append("linearGradient")
                            .attr("id", gradId)
                            .attr("gradientUnits", "userSpaceOnUse")
                            .attr("x1", prevPoint[0]).attr("y1", prevPoint[1])
                            .attr("x2", thisPoint[0]).attr("y2", thisPoint[1])
                            .selectAll("stop")
                            .data(function (d) { return [prevDgt, dgt]})
                            .enter().append("stop")
                            .attr("offset", function(_, i) { return i * 100 + "%"; })
                            .attr("stop-color", function(d) {
                                return d3.rgb(fillPerDigit(d));
                            });
                }

                // add connection line
                var animMs = animMaxMs * (1 - (1 + Math.log((numAddedLines + 1) / (digits.length - 1)) / (Math.E * Math.E)));
                var connectionLine = connectionGroup.append("path")
                        .attr("d", line([prevPoint, middlePoint, thisPoint]))
                        .style("stroke", function(d) { return "url(#" + gradId })
                        .style("stroke-opacity", 0.0)
                        .transition()
                        .duration(animMs)
                        .delay(prevAnimMs)
                        .style("stroke-opacity", 0.75);

                prevAnimMs = prevAnimMs + animMs;
                numAddedLines++;
            }

            drawn[dgtInt]++;
            prevPoint = thisPoint;
            prevDgt = dgt;
        }
    }

    function histForDigits(digits) {
        // init
        var hist = new Array(10).fill(0);

        // count
        for (var i = 0; i < digits.length; i++) {
            var dgt = digits.charAt(i);
            hist[parseInt(dgt)]++;
        }

        return hist;
    }
</script>

</body>
